package com.atguigu.tree;

import java.util.Arrays;

/**
 * @author shengxiao
 * @date 2021/7/25 10:14
 *
 * 注意：我们将给定的一个数组，脑补成一个完全二叉树【可能还是满二叉树】
 */
public class HeapSort {

    public static void main(String[] args) {
        // 要求将数组进行升序排序
        int[] arr = {4,6,8,5,9} ;
        heapSort(arr);
        /*
        // 创建80000个的随机的数组
        int[] arr = new int[8000000] ;
        for(int i = 0 ; i < 8000000 ; i++){
            arr[i] = (int) (Math.random() * 80000000);  // 生成一个[0,8000000)的数，为什么要取怎么大，为了避免取到相同的值
        }
//        Date date1 = new Date() ;   // 实体类
//        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
//        String date1Str = sdf.format(date1);
//        System.out.println("排序前的时间是=" + date1Str);

        long before = System.currentTimeMillis() ;
        //System.out.println("排序前的时间是=" + System.currentTimeMillis()) ;

        heapSort(arr);

//        Date date2 = new Date() ;   // 实体类
//        String date2Str = sdf.format(date2);
//        System.out.println("排序后的时间是=" + date2Str);  // 选择排序用时4s
        long after = System.currentTimeMillis() ;

        System.out.println("执行总时间" + (after - before) / 1000.0 + "s");    // 80000数据，执行总时间0.014s
                                                                              // 800000数据，执行总时间0.213s
                                                                             // 8000000数据，执行总时间2.496s

         */

    }


    // 编写一个堆排序的方法
    public static void heapSort(int[] arr){
        int temp = 0 ;  // 用来交换首尾元素的临时变量
        System.out.println("堆排序！！");

        // 分步完成
//        adjustHeap(arr, 1, arr.length);
//        System.out.println("第一次" + Arrays.toString(arr));   // 4,9,8,5,6

//        为什么此时不会将表示对多少个元素的调整，length - 1？？
        // 因为第一次调整，并没有找到一个真正最大的数，故调整的数组元素还是length
//        adjustHeap(arr, 0, arr.length);
//        System.out.println("第二次" + Arrays.toString(arr));   // 9,6,8,5,4

        // 完成我们的最终代码
        // 1）将待排序序列构造成一个大顶堆,根据升序降序需求选择大顶堆或小顶堆
        // 叶子节点是从根节点开始计数，然后从上到下，从左向右计数，故 arr.length / 2 - 1 求出来的是最后一个非叶子节点的【索引值】

        // arr.length / 2 - 1 求出来的是最后一个非叶子节点的【索引值】，从右向左，从下向上进行遍历调整
        // "从下向上"和"从右向左"都是完全二叉树而言，不懂可以自己根据要排序的数组，脑补一个完全二叉树
        // 但切记：在每一个非叶子节点处判断时，其左子节点和右子节点要从左向右查看
        // 综上：这里并没有递归入栈，而是每次执行完一个adjustHeap()后，返回到调用点，然后再次进行遍历，并没有涉及到递归
        // 当第一次for循环执行完毕之后，会产生一个大堆顶，然后执行第二个for循环

        // 此for循环是确定非叶子节点的左子节点,切记：完全二叉树，如果是最后一个非叶子节点，那么一定会存在左子节点，不一定存在右子节点
        // 故下面需要对右子节点进行判断，k + 1 < length，避免越界
        // 其实：这里的k也可以看做是一个指针【指示器】
        for(int i = arr.length / 2 - 1 ; i >= 0 ; i--){
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr, i, arr.length); // 注意：每一趟局部堆顶，都会选出一个当前排序的局部最大堆顶
        }

        /**
         * 关于上下两个for循环调用adjustHeap()方法的区别  【明确一点：这里并没有用到递归】
         * 上面调用adjustHeap()方法，目的是生成第一个大顶堆而我们获取大顶堆需要从最后一个非叶子节点进行搜索，此时得到第一个最大值，然后下面的for循环将第一个和最后一个元素交换，只会将其 最大值元素分隔开，下一次不用考虑
         * 而下面的for循环调用adjustHeap()方法是为了得到最大值的堆顶元素，因为此时刚好从第一次获取到大顶堆的元素时候，除了第一个元素和最后一个元素进行交换，
         * 【其他元素的相对位置】没有变化，故第二次获取大顶堆速度会变得很快，因为 此时我们传入的参数是adjustHeap(arr, 0, j);即把第一个位置的元素的index=0传入，此时，当前的堆顶元素，
         * 虽然不是最大值，但其和左右子节点元素进行比较，得到此时的最大值，并不一定是最终大堆顶的最大值
         * 若此时若还有左子节点，此时需要再次循环，下一次判断是否下一次节点是局部调整的最大值，若是，则就直接break；否则又要调整；以此类推
         *  然后将当前序列和最后一个元素和大堆顶的堆顶元素进行交换。之后以此类推。
         *
         * 综上：第一次获取大堆顶需要局部调整多次，直到i=0，此时得到大堆顶。
         * 第2,3.。。n次之后，此时需先将之前的堆顶元素和其相邻的左右子节点进行比较，
         * 然后若左子节点任然存在左子节点[i=k条件 结合 k = k * 2 + 1 之后的k值不操作当前]将将较大的元素放到堆顶处，局部调整一次，
         * 此时还需要看看是否有左子节点，以及是否在 有左子节点的时候后 ，此时的节点不是局部的大堆顶，若满足，则又要进行交换，得到最后的大堆顶。
         *
         * 老师独家讲解：
         *      但是 你要明确一点的是，刚开始我们是为了效率比较好，所以才会先处理最后一个非叶子节点，如果是真实调整的话，是从根节点开始进行调整
         *      并且：你要记得其实第一次获取到的大堆顶后，其相对的位置关系大体已经确定，故，此时直接从堆顶元素出发，可能只需要调整一次即可得到最大元素【理想情况】
         *          如果不理想的话，也是正常的，此时调整的次数就不止一次。【原因在于有不确定的因素：是否在 有左子节点的时候后 ，此时的节点是否是局部的大堆顶】
         */

        /**
         * 2) 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端
         * 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，
         *     反复执行调整+交换步骤，直到整个序列有序。
         */
        // 第二个for循环是不断的交换和重构，此时除了第一次排序生成的第一个大堆顶是在第一个for循环形成的，
        // 其他剩下的每一趟生成的大堆顶都是在第二个for循环内部实现的，并没有再执行第一个for循环代码
        // 临界条件：若之前j=2，即还剩下两个元素 执行adjustHeap(arr, 0, j)，之后j-- 得到j=1，故此时arr[j]=arr[1],其还需和arr[0]进行交换元素，
        // 之后进入adjustHeap(arr, 0, j);方法，因为此时只剩下一个元素，j=1，故就直接不符合条件，跳出循环，
        // 即最后这一次也需要进入，因为前面变量j定义的方式，如果退出的条件改为j > 1,则会造成若第一个位置和第二个位置的元素arr[0]，arr[1]是逆序的，则此时无法进行交换
        // 综上：此处for循环的j：代表要交换元素【当前要调整元素的最后一个元素】的下标
        for(int j = arr.length - 1 ; j > 0 ; j--){  // 一共有arr.length = 5 个元素，故我们只需调整【即交换元素】大堆顶四次
            // 交换
            // 每一次交换都是和堆顶元素交换，即arr[0],下标为0的堆顶元素
            temp = arr[j] ;
            arr[j] = arr[0] ;
            arr[0] = temp ;
            adjustHeap(arr, 0, j);  // why？？？   综上：此处的j：代表要调整元素的个数
                                      // 故虽然两处是同一个变量j，但表示的意思不同
        }

        System.out.println("数组=" + Arrays.toString(arr));


    }

    // 将一个数组（脑补为一个完全二叉树，此 完全二叉树 按照数组的顺序存储），然后将其调整成一个大顶堆

    /**
     * 功能：完成 将 以 i 对应的非叶子节点的树调整为大顶堆
     * 举例：int[] arr = {4,6,8,5,9}; => i = 1 => adjustHeap => 得到{4,9,8,5,6}
     * 如果我们再次调用adjustHeap  传入的是 i = 0 => 得到{4,9,8,5,6} => {9,6,8,5,4}
     * @param arr   待调整的数组
     * @param i     表示非叶子节点在数组中的索引  【注意：i=0代表是数组的第一个元素，也是二叉树的第一个节点】
     * @param length    表示对多少个元素的调整，length 是在逐渐减少
     *
     *  我一直以为每一次调用adjustHeap()方法都会生成一个大顶堆，并不是，第一次调用会生成，当前非叶子节点的堆顶（局部调整）
     *  此时还需要进行从右向左，从下向上，然后生成每一次的堆顶，当最后i=0时候，此时调整好次序时，此时的堆顶即为大堆顶。此时才刚刚找到了一个最大值，
     *  将其和最后一个位置的元素交换位置，这才是第一次大顶堆的调整【里面涉及到多个局部堆顶的调整】，下一次将最后一个位置的最大元素不作为下一趟进行
     *  调整大堆顶的元素，故此时 arr.length-1
     */
    public static void adjustHeap(int[] arr,int i ,int length){

        int temp  = arr[i] ;    // 先取出当前元素的值，保存在临时变量
        // 开始调整
        // 说明
        // 1. k = i * 2 + 1  => k 是 i节点的左子节点
        // 2. length ：代表调整当前堆的时候的元素个数，不包括已调整好的
        // 3. for循环最后的一个k的增量：k = k * 2 + 1是为了处理可能当前叶子节点的左子树还存在左子节点
        for(int k = i * 2 + 1 ; k < length ; k = k * 2 + 1){
            // k + 1 < length：添加这一句是为了加快检索的效率，同时捎带也对左子树的右子节点进行判断
            if(k + 1 < length && arr[k] < arr[k + 1]){    // 说明左子节点的值小于右子节点的值
                k++ ;   // 当符合上面的if条件后， k 指向右子节点
            }

            if(arr[k] > temp){  // 如果子节点大于父节点
                // 把较大的值，赋给当前
                arr[i] = arr[k] ;   // 将子节点的值移动到前面父节点处，而父节点的原始值由temp保存

                // 下面这种情况可能是在什么情况下出现 ???
                // 如果之前已经局部对非叶子节点进行大顶堆的局部排序，但是在经过几趟排序后，
                // 此之前的非叶子节点恰好又是当前节点的左子节点，那么此时就要考虑如果当前节点的元素值比之前的非叶子节点的元素值小，
                // 那么在交换后，如果之前排序好的局部大堆顶造成影响后，之前非叶子节点的元素值比其左右子节点小，则此时还需要再次向
                // 其左子节点进行大顶堆排序，即相当于这一趟排序，其实是多排序了之前排序过的堆顶，【把之前的那个影响了】；

                // 而如果之前的非叶子节点恰好又是当前节点的左子节点，但此时当前节点的元素值比之前的非叶子节点的元素值小大
                // 此时在这趟堆顶排序时候，就可以直接跳过下面这个本不该移动的代码判断，即直接执行下面的break语句
                i = k ;  // ！！！ i 指向 k，继续循环比较，把 i看做是一个指针，可能当前叶子节点的左子树还存在左子节点，
                        //  // 所以需要对原来的非叶子节点的索引值i 进行 覆盖
            }else{  //arr[k] <= temp
                break ;     // 难点！！！这里为什么可直接break；【无论该节点是否存在子节点，满足arr[k] <= temp条件，都可以跳出循环】
                            // 但实际上最根本的原因是arr[k] <= temp，且非叶子节点是按照从右向左，从下向上的顺序查找【子节点是按照从左向右查找】
                            // 故如果这个条件满足，则说明此排序没有要进行交换元素，而之前的排序好的也不用动了。故就可以直接跳出循环

                            // 因为我们进行堆顶局部排序时候，是遵循，从右向左，从下到上的方向进行局部堆顶排序。
                            // 故下面的顺序，如果arr[k]没有变化位置，说明还是可以按照之前的顺序排列，故就不用比较了
                            // 如果变化位置，那就是上面arr[k] > temp的情况，此时
            }
        }
        // 当for循环结束后，我们己经将以i 为父节点的树的最大值，放在了 排序当前非叶子节点的堆顶（局部调整）
        arr[i] = temp ; // 将temp值放到调整后的位置
    }
}

